///////////////////////////////////////////////////////////////////////////////
//  File generated by HDevelop for HALCON/C++ Version 12.0
///////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "MyHalconEx.h"
#include <direct.h>

void GenRegionCross(HObject *ho_RegionUnion,HTuple hv_row, HTuple hv_col, HTuple hv_size)
{
	HObject  ho_RegionLines, ho_RegionLines1;
	ho_RegionLines.GenEmptyObj();
	ho_RegionLines1.GenEmptyObj();
	GenRegionLine(&ho_RegionLines, hv_row-hv_size, hv_col-hv_size, hv_row+hv_size, hv_col+hv_size);
	GenRegionLine(&ho_RegionLines1, hv_row-hv_size, hv_col+hv_size, hv_row+hv_size, hv_col-hv_size);
	Union2(ho_RegionLines, ho_RegionLines1, &(*ho_RegionUnion));
	return;
}
void MeanReducedImage (HObject ho_ImageReduced, HObject *ho_ImageMean, HTuple hv_MaskWidth, 
    HTuple hv_MaskHeight)
{

  // Local iconic variables
  HObject  ho_Domain, ho_ConnectedRegions, ho_MeanCropImage;
  HObject  ho_ObjectSelected, ho_ImageReduced1, ho_ImagePart;
  HObject  ho_PartImageMean, ho_ObjectsConcat;

  // Local control variables
  HTuple  hv_Number, hv_Index, hv_Width1, hv_Height1;
  HTuple  hv_MinMaskWidth, hv_MinMaskHeight, hv_Width, hv_Height;
  HTuple  hv_Row1, hv_Column1, hv_Row2, hv_Column2, hv_Newtuple;

  GetDomain(ho_ImageReduced, &ho_Domain);
  Connection(ho_Domain, &ho_ConnectedRegions);
  ShapeTrans(ho_ConnectedRegions, &ho_ConnectedRegions, "inner_rectangle1");
  CountObj(ho_ConnectedRegions, &hv_Number);
  GenEmptyObj(&ho_MeanCropImage);
 {
  HTuple end_val5 = hv_Number;
  HTuple step_val5 = 1;
  for (hv_Index=1; hv_Index.Continue(end_val5, step_val5); hv_Index += step_val5)
  {
    SelectObj(ho_ConnectedRegions, &ho_ObjectSelected, hv_Index);
    ReduceDomain(ho_ImageReduced, ho_ObjectSelected, &ho_ImageReduced1);
    CropDomain(ho_ImageReduced1, &ho_ImagePart);
    GetImageSize(ho_ImagePart, &hv_Width1, &hv_Height1);
    TupleMin2(hv_MaskWidth, hv_Width1, &hv_MinMaskWidth);
    TupleMin2(hv_MaskHeight, hv_Height1, &hv_MinMaskHeight);
    MeanImage(ho_ImagePart, &ho_PartImageMean, hv_MinMaskWidth, hv_MinMaskHeight);
    ConcatObj(ho_MeanCropImage, ho_PartImageMean, &ho_MeanCropImage);
  }
  }
  GetImageSize(ho_ImageReduced, &hv_Width, &hv_Height);
  ConcatObj(ho_ImageReduced, ho_MeanCropImage, &ho_ObjectsConcat);
  SmallestRectangle1(ho_ConnectedRegions, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
  TupleGenConst(hv_Number+1, -1, &hv_Newtuple);
  TileImagesOffset(ho_ObjectsConcat, &(*ho_ImageMean), HTuple(0).TupleConcat(hv_Row1), 
      HTuple(0).TupleConcat(hv_Column1), hv_Newtuple, hv_Newtuple, hv_Newtuple, hv_Newtuple, 
      hv_Width, hv_Height);
  return;

}
void FoilDetect (HObject ho_Image, HObject ho_ImageMean, HObject ho_ImageRegion, 
    HObject ho_hoSumRegion, HObject *ho_ErrorRegion, HTupleVector/*{eTupleVector,Dim=1}*/ hvec_Param, 
    HTuple hv_PeakGray)
{

  // Local iconic variables
  HObject  ho_FoilRegion, ho_ImageReduced, ho_Region;
  HObject  ho_RegionClosing, ho_ConnectedRegions, ho_Rectangle;
  HObject  ho_ImageReduced1, ho_Region1, ho_ConnectedRegions1;
  HObject  ho_SelectedRegions, ho_RegionUnion;

  // Local control variables
  HTuple  hv_bDetect, hv_dResolution, hv_dFoilThresh;
  HTuple  hv_dBlackLineMinDiameter, hv_dwMaxArea, hv_Width;
  HTuple  hv_Height, hv_Row1, hv_Column1, hv_Row2, hv_Column2;
  HTuple  hv_Area, hv_Row, hv_Column;

  //Param := {['是否检测',1],['极耳区域阈值',30],['带料直径最小值(mm)',0.3],['比例尺',0.056]}
  GenEmptyObj(&(*ho_ErrorRegion));
  hv_bDetect = ((const HTuple&)hvec_Param[0].T())[1];
  if (0 != (0==hv_bDetect))
  {
    return;
  }
  hv_dResolution = ((const HTuple&)hvec_Param[HTuple(hvec_Param.Length())-1].T())[1];
  hv_dFoilThresh = ((const HTuple&)hvec_Param[1].T())[1];
  hv_dBlackLineMinDiameter = HTuple(hvec_Param[2].T()[1])/hv_dResolution;
  hv_dwMaxArea = ((const HTuple&)hvec_Param[3].T())[1];
  SelectObj(ho_ImageRegion, &ho_FoilRegion, 1);
  ErosionRectangle1(ho_FoilRegion, &ho_FoilRegion, 10, 10);
  ReduceDomain(ho_Image, ho_FoilRegion, &ho_ImageReduced);
  Threshold(ho_ImageReduced, &ho_Region, 0, hv_dFoilThresh);
  ClosingCircle(ho_Region, &ho_RegionClosing, 3.5);
  Difference(ho_RegionClosing, ho_hoSumRegion, &ho_RegionClosing);
  Connection(ho_RegionClosing, &ho_ConnectedRegions);
  SelectShape(ho_ConnectedRegions, &(*ho_ErrorRegion), "max_diameter", "and", hv_dBlackLineMinDiameter, 
      99999);
  //*****极耳有无粘连
  GetImageSize(ho_ImageReduced, &hv_Width, &hv_Height);
  SmallestRectangle1(ho_FoilRegion, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
  if (0 != (hv_Column1>(hv_Width/2)))
  {
    GenRectangle1(&ho_Rectangle, 0, hv_Column1, hv_Height, hv_Column2+100);

  }
  else
  {
    GenRectangle1(&ho_Rectangle, 0, 200, hv_Height, hv_Column2);
  }
  ReduceDomain(ho_Image, ho_Rectangle, &ho_ImageReduced1);
  Threshold(ho_ImageReduced1, &ho_Region1, 200, 255);
  Connection(ho_Region1, &ho_ConnectedRegions1);
  SelectShape(ho_ConnectedRegions1, &ho_SelectedRegions, "area", "and", 50, 99999999);
  Union1(ho_SelectedRegions, &ho_RegionUnion);
  AreaCenter(ho_RegionUnion, &hv_Area, &hv_Row, &hv_Column);
  if (0 != (hv_Area>hv_dwMaxArea))
  {
    ConcatObj((*ho_ErrorRegion), ho_RegionUnion, &(*ho_ErrorRegion));
  }
  return;
}
void WidthLine(HObject ho_Rectangle, HTuple *hv_Width, HTuple* hvLength)
{

	// Local iconic variables
	HObject  ho_ObjectSelected, ho_RegionMoved, ho_Skeleton;
	HObject  ho_DistanceImage;

	// Local control variables
	HTuple  hv_Number, hv_Index, hv_hvRow1, hv_hvColumn1, hv_Area;
	HTuple  hv_ExpDefaultCtrlDummyVar, hv_Min, hv_Max, hv_hv_Range;

	CountObj(ho_Rectangle, &hv_Number);
	TupleGenConst(hv_Number, 0, &(*hv_Width));
	TupleGenConst(hv_Number, 0, &(*hvLength));
	{
		HTuple end_val2 = hv_Number;
		HTuple step_val2 = 1;
		for (hv_Index = 1; hv_Index.Continue(end_val2, step_val2); hv_Index += step_val2)
		{
			SelectObj(ho_Rectangle, &ho_ObjectSelected, hv_Index);
			SmallestRectangle1(ho_ObjectSelected, &hv_hvRow1, &hv_hvColumn1, &hv_ExpDefaultCtrlDummyVar,
				&hv_ExpDefaultCtrlDummyVar);
			MoveRegion(ho_ObjectSelected, &ho_RegionMoved, -hv_hvRow1, -hv_hvColumn1);
			Skeleton(ho_RegionMoved, &ho_Skeleton);
			DistanceTransform(ho_RegionMoved, &ho_DistanceImage, "chessboard", "true", 800,
				800);
			MinMaxGray(ho_Skeleton, ho_DistanceImage, 0, &hv_Min, &hv_Max, &hv_hv_Range);
			(*hv_Width)[hv_Index - 1] = hv_Max * 2;
			AreaCenter(ho_Skeleton, &hv_Area, NULL, NULL);
			(*hvLength)[hv_Index - 1] = hv_Area;
		}
	}

	return;
}
void MostGrayValue (HObject ho_Region, HObject ho_Image, HTuple *hv_PeakGray)
{
	try
	{
	// Local control variables
	HTuple  hv_AbsoluteHisto, hv_RelativeHisto, hv_Indices;
	GrayHisto(ho_Region, ho_Image, &hv_AbsoluteHisto, &hv_RelativeHisto);
	TupleSortIndex(hv_AbsoluteHisto, &hv_Indices);
	TupleSelect(hv_Indices, 255, &(*hv_PeakGray));
	return;
	}catch(HException& e)
	{
		AfxMessageBox("MostGrayValue出错！");
	}
}
void SegmentRegion(HObject& ho_Coat, HObject& ho_Foil, HObject ho_AT9Region, HObject *ho_Mid,
	HObject *ho_Border,HObject* ho_EdgeDrop,HObject* ho_Corner, HTuple hv_dBorderWidth,HTuple hv_dEdgeWidth,HTuple hv_dCornerWidth)
{

	// Local iconic variables
	HObject  ho_DilationRectangle, ho_ErosionRectangle;
	HObject  ho_RegionDifference, ho_ConnectedRegions, ho_ObjectSelected1;
	HObject  ho_ObjectSelected2;
	// Local control variables
	HTuple  hv_Number, hv_Area, hv_RowRef, hv_ColumnRef;
	HTuple  hv_Area1, hv_Row1, hv_Column1, hv_Area2, hv_Row2;
	HTuple  hv_Column2, hv_Distance1, hv_Distance2, hv_Exception;
	HObject ho_DilatinFoil;
	//分割涂布区域
	try
	{
		DilationRectangle1(ho_AT9Region, &ho_DilationRectangle, 5, 1);
		Difference(ho_Coat, ho_DilationRectangle, &ho_Coat);
		ErosionRectangle1(ho_Coat, &ho_ErosionRectangle, hv_dBorderWidth, 1);
		Difference(ho_Coat, ho_ErosionRectangle, &ho_RegionDifference);

		if (g_nLaneCount==2)
		{
			Connection(ho_RegionDifference, &ho_ConnectedRegions);
			CountObj(ho_ConnectedRegions, &hv_Number);
			////选择靠近极耳一侧的区域作为边界区域
			if (0 != (hv_Number > 1))
			{
				AreaCenter(ho_Foil, &hv_Area, &hv_RowRef, &hv_ColumnRef);
				SelectObj(ho_ConnectedRegions, &ho_ObjectSelected1, 1);
				SelectObj(ho_ConnectedRegions, &ho_ObjectSelected2, 2);
				AreaCenter(ho_ObjectSelected1, &hv_Area1, &hv_Row1, &hv_Column1);
				AreaCenter(ho_ObjectSelected2, &hv_Area2, &hv_Row2, &hv_Column2);
				TupleAbs(hv_Column1 - hv_ColumnRef, &hv_Distance1);
				TupleAbs(hv_Column2 - hv_ColumnRef, &hv_Distance2);
				if (0 != (hv_Distance1 <= hv_Distance2))
				{
					(*ho_Border) = ho_ObjectSelected1;
				}
				else
				{
					(*ho_Border) = ho_ObjectSelected2;
				}
			}
			else
			{
				GenEmptyObj(&(*ho_Border));
			}
			///避免极耳处误检，需要将靠近极耳的地方做一下处理
			DilationRectangle1(ho_Foil, &ho_DilatinFoil, 95, 155);
			Difference(ho_AT9Region,ho_DilatinFoil,&ho_AT9Region);//AT9区域
			///将边界从涂布区域中扣去，得到中心涂布区域 
			Difference(ho_Coat, (*ho_Border), &(*ho_Mid));//涂布中心区域
			///边界也是一样
			Difference((*ho_Border),ho_DilatinFoil,&(*ho_Border));//边界区域
			////分割边缘掉料区域
			HObject ho_EdgeDilation,ho_EdgeErosion,ho_EdageDifference;
			DilationRectangle1(ho_Coat,&ho_EdgeDilation,hv_dEdgeWidth,1);
			ErosionRectangle1(ho_Coat,&ho_EdgeErosion,hv_dEdgeWidth,1);
			Difference(ho_EdgeDilation,ho_EdgeErosion,&ho_EdageDifference);
			Connection(ho_EdageDifference, &ho_ConnectedRegions);
			CountObj(ho_ConnectedRegions, &hv_Number);
			////选择靠近极耳一侧的区域作为边界区域
			if (0 != (hv_Number > 1))
			{
				AreaCenter(ho_Foil, &hv_Area, &hv_RowRef, &hv_ColumnRef);
				SelectObj(ho_ConnectedRegions, &ho_ObjectSelected1, 1);
				SelectObj(ho_ConnectedRegions, &ho_ObjectSelected2, 2);
				AreaCenter(ho_ObjectSelected1, &hv_Area1, &hv_Row1, &hv_Column1);
				AreaCenter(ho_ObjectSelected2, &hv_Area2, &hv_Row2, &hv_Column2);
				TupleAbs(hv_Column1 - hv_ColumnRef, &hv_Distance1);
				TupleAbs(hv_Column2 - hv_ColumnRef, &hv_Distance2);
				if (0 != (hv_Distance1 <= hv_Distance2))
				{
					(*ho_EdgeDrop) = ho_ObjectSelected1;
				}
				else
				{
					(*ho_EdgeDrop) = ho_ObjectSelected2;
				}
			}
			else
			{
				GenEmptyObj(&(*ho_EdgeDrop));

			}

			ErosionRectangle1(*ho_EdgeDrop,ho_EdgeDrop,1,25);
			ErosionRectangle1(*ho_Border,ho_Border,1,25);

			Difference((*ho_EdgeDrop),ho_DilatinFoil,&(*ho_EdgeDrop));//边线区域
			GenEmptyObj(ho_Corner);//边角区域
		}else
		{
			*ho_Mid=ho_ErosionRectangle;
			DilationRectangle1(ho_Foil, &ho_DilatinFoil, 15, 15);
			Difference(ho_RegionDifference,ho_DilatinFoil,&(*ho_Border));//边界区域
			HObject ho_EdgeDilation,ho_EdgeErosion;
			DilationRectangle1(ho_Coat,&ho_EdgeDilation,hv_dEdgeWidth,1);
			ErosionRectangle1(ho_Coat,&ho_EdgeErosion,hv_dEdgeWidth,1);
			Difference(ho_EdgeDilation,ho_EdgeErosion,&(*ho_EdgeDrop));
			Difference((*ho_EdgeDrop),ho_DilatinFoil,&(*ho_EdgeDrop));//边线区域
			///避免极耳处误检，需要将靠近极耳的地方做一下处理
			Difference(ho_AT9Region,ho_DilatinFoil,&ho_AT9Region);//AT9区域
			GenEmptyObj(ho_Corner);//边角区域

		}







	}
	// catch (Exception) 
	catch (HalconCpp::HException &HDevExpDefaultException)
	{
		HDevExpDefaultException.ToHTuple(&hv_Exception);
		//
	}
	//
	return;
}

void SelectAdjacentLine (HObject ho_Region, HObject ho_ObjectsConcat, HObject *ho_SelectedRegions)
{

	// Local control variables
	HTuple  hv_Number, hv_ExpDefaultCtrlDummyVar;
	HTuple  hv_Columns, hv_Column0, hv_DistanceAbs, hv_Indices;


	GenEmptyObj(&(*ho_SelectedRegions));
	CountObj(ho_ObjectsConcat, &hv_Number);
	if (0 != (4==hv_Number))
	{
		AreaCenter(ho_ObjectsConcat, &hv_ExpDefaultCtrlDummyVar, &hv_ExpDefaultCtrlDummyVar, 
			&hv_Columns);
		AreaCenter(ho_Region, &hv_ExpDefaultCtrlDummyVar, &hv_ExpDefaultCtrlDummyVar, 
			&hv_Column0);
		TupleAbs(hv_Columns-hv_Column0, &hv_DistanceAbs);
		TupleSortIndex(hv_DistanceAbs, &hv_Indices);
		SelectObj(ho_ObjectsConcat, &(*ho_SelectedRegions), HTuple(hv_Indices[0])+1);
	}
	return;
}

void SelectLine (HObject ho_Rectangle, HObject *ho_ErrorRegion, HTuple hv_StandarWidth, 
	HTuple hv_StandarLength, HTuple *hv_hvWidth, HTuple *hv_hvLength)
{

	// Local iconic variables
	HObject  ho_Skeleton, ho_ObjectSelected, ho_ObjectSelected1;

	// Local control variables
	HTuple  hv_Number, hv_Area, hv_Row, hv_Column;
	HTuple  hv_Greater, hv_Indices, hv_Row1, hv_Column1, hv_Radius;
	HTuple  hv_GreaterRadius, hv_Indices1;

	GenEmptyObj(&(*ho_ErrorRegion));
	CountObj(ho_Rectangle, &hv_Number);
	TupleGenConst(hv_Number, 0, &(*hv_hvWidth));
	TupleGenConst(hv_Number, 0, &(*hv_hvLength));
	Skeleton(ho_Rectangle, &ho_Skeleton);
	AreaCenter(ho_Skeleton, &hv_Area, &hv_Row, &hv_Column);
	TupleGreaterElem(hv_Area, hv_StandarLength, &hv_Greater);
	TupleFind(hv_Greater, 1, &hv_Indices);
	if (0 != (-1!=hv_Indices))
	{
		SelectObj(ho_Rectangle, &ho_ObjectSelected, hv_Indices+1);
		InnerCircle(ho_ObjectSelected, &hv_Row1, &hv_Column1, &hv_Radius);
		TupleGreaterElem(hv_Radius*2, hv_StandarWidth, &hv_GreaterRadius);
		TupleFind(hv_GreaterRadius, 1, &hv_Indices1);
		if (0 != (-1!=hv_Indices1))
		{
			SelectObj(ho_ObjectSelected, &ho_ObjectSelected1, hv_Indices1+1);
			ConcatObj((*ho_ErrorRegion), ho_ObjectSelected1, &(*ho_ErrorRegion));

		}
	}
	return;
}

void SelectSuitableLine (HObject ho_Rectangle, HObject *ho_ErrorRegion, HTuple hv_StandarWidthMin, 
    HTuple hv_StandarWidthMax, HTuple hv_StandarLength, HTuple *hv_hvWidth, HTuple *hv_hvLength)
{

  // Local iconic variables
  HObject  ho_ObjectSelected, ho_RegionMoved, ho_Skeleton;
  HObject  ho_DistanceImage;

  // Local control variables
  HTuple  hv_Number, hv_i, hv_Row1, hv_Column1;
  HTuple  hv_Row2, hv_Column2, hv_WidthValue, hv_HeightValue;
  HTuple  hv_DiagonalLength, hv_Min, hv_Max, hv_Range, hv_Area;
  HTuple  hv_Row, hv_Column, hv_LenthDiffAbs;

  GenEmptyObj(&(*ho_ErrorRegion));
  CountObj(ho_Rectangle, &hv_Number);
  TupleGenConst(hv_Number, 0, &(*hv_hvWidth));
  TupleGenConst(hv_Number, 0, &(*hv_hvLength));
  {
  HTuple end_val4 = hv_Number;
  HTuple step_val4 = 1;
  for (hv_i=1; hv_i.Continue(end_val4, step_val4); hv_i += step_val4)
  {
    SelectObj(ho_Rectangle, &ho_ObjectSelected, hv_i);
    SmallestRectangle1(ho_ObjectSelected, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
    MoveRegion(ho_ObjectSelected, &ho_RegionMoved, -hv_Row1, -hv_Column1);
    Skeleton(ho_RegionMoved, &ho_Skeleton);
    RegionFeatures(ho_RegionMoved, "width", &hv_WidthValue);
    RegionFeatures(ho_RegionMoved, "height", &hv_HeightValue);
    TupleSqrt((hv_WidthValue*hv_WidthValue)+(hv_HeightValue*hv_HeightValue), &hv_DiagonalLength);
    //
    DistanceTransform(ho_RegionMoved, &ho_DistanceImage, "chessboard", "true", 800, 
        800);
    MinMaxGray(ho_Skeleton, ho_DistanceImage, 0, &hv_Min, &hv_Max, &hv_Range);
    (*hv_hvWidth)[hv_i-1] = hv_Max*2;
    AreaCenter(ho_Skeleton, &hv_Area, &hv_Row, &hv_Column);
    TupleAbs(hv_Area-hv_DiagonalLength, &hv_LenthDiffAbs);
    (*hv_hvLength)[hv_i-1] = hv_Area;
    if (0 != (HTuple(HTuple(HTuple((hv_Max*2)>hv_StandarWidthMin).TupleAnd((hv_Max*2)<hv_StandarWidthMax)).TupleAnd(hv_Area>hv_StandarLength)).TupleAnd(hv_LenthDiffAbs<hv_DiagonalLength)))
    {
      ConcatObj((*ho_ErrorRegion), ho_ObjectSelected, &(*ho_ErrorRegion));
    }
  }
  }
  return;
}




